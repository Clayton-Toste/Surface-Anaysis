from __future__ import print_function
import math

import re
import pymol
cmd = __import__("sys").modules["pymol.cmd"]
from . import setting
from . import parsing
import threading

from .cmd import DEFAULT_ERROR, DEFAULT_SUCCESS, _raising, \
     is_list,  is_string, is_error

_prefix = "_tmp_editor"
tmp_wild = _prefix + "*"
tmp_editor = _prefix + "0"
tmp_connect = _prefix + "_con"
tmp_domain = _prefix + "_dom"
tmp1 = _prefix + "1"
tmp2 = _prefix + "2"
tmp3 = _prefix + "3"
tmp4 = _prefix + "4"

# routines to assist in molecular editing

class undocontext:
    def __init__(self, cmd, sele):
        self.cmd = cmd
        self.sele = sele

    def __enter__(self):
        self.suspend_undo = self.cmd.get_setting_int("suspend_undo")
        if not self.suspend_undo:
            self.cmd.push_undo(self.sele, 0)
            self.cmd.set("suspend_undo", 1, updates=0)

    def __exit__(self, exc_type, exc_value, traceback):
        if not self.suspend_undo:
            finish = 1 if exc_type is None else -1
            self.cmd.set("suspend_undo", 0, updates=0)
            self.cmd.push_undo("", 0, finish_undo=finish)

def attach_fragment(selection,fragment,hydrogen,anchor,_self=cmd):
    '''
ARGUMENTS

    selection = str: must be "pk1"

    fragment = str: fragment name to load from fragment library

    hydrogen = int: hydrogen atom ID in fragment to fuse

    anchor = int: none-hydrogen atom ID in fragment to fuse
    '''
    with undocontext(_self, "(%s) extend 1" % selection):
        if not selection in _self.get_names("selections"):
            if fragment in _self.get_names("objects"):
                raise pymol.CmdException("an object with that name already exists")
            else:
                _self.fragment(fragment)
                if _self.get_setting_boolean("auto_remove_hydrogens"):
                    _self.remove("(hydro and %s)"%fragment)
        else:
            _self.fragment(fragment,tmp_editor, origin=0)
            if _self.count_atoms("((%s) and elem H)"%selection,quiet=1):
                _self.fuse("(%s and id %d)"%(tmp_editor,hydrogen),"(pk1)",1)
                if _self.get_setting_boolean("auto_remove_hydrogens"):
                    _self.remove("(hydro and pkmol)")            
            else:
                _self.remove("(%s and id %d)"%(tmp_editor,hydrogen))
                _self.fuse("(%s and id %d)"%(tmp_editor,anchor),"(pk1)",1)
                if _self.get_setting_boolean("auto_remove_hydrogens"):
                    _self.remove("(hydro and pkmol)")            
                elif _self.count_atoms('hydro and (neighbor pk2)'):
                    _self.h_fill()
            _self.delete(tmp_editor)

def combine_fragment(selection,fragment,hydrogen,anchor,_self=cmd):
    with undocontext(_self, selection):
        _self.fragment(fragment,tmp_editor)
        try:
            if _self.get_setting_boolean("auto_remove_hydrogens"):
                _self.remove("(hydro and ?%s)" % tmp_editor)
            _self.fuse("?%s" % tmp_editor, "(%s)" % selection, 3)
        finally:
            _self.delete(tmp_editor)

#from time import time as ___time
#___total = 0.0
#___seg1 = 0.0
#___seg2 = 0.0
#___seg3 = 0.0
#___pass = 0
#___last = ___time()

def attach_amino_acid(selection,amino_acid,center=0,animate=-1,object="",hydro=-1,ss=-1,_self=cmd):
    '''
ARGUMENTS

    selection = str: named selection of single N or C atom

    amino_acid = str: fragment name to load from fragment library

    center = bool: center on new terminus (pk1)

    animate = int: animate centering

    object = str: name of new object (if selection is none)

    hydro = int (-1/0/1): keep hydrogens

    ss = int: Secondary structure 1=alpha helix, 2=antiparallel beta, 3=parallel beta, 4=flat
    '''
#    global ___total, ___seg1, ___seg2, ___seg3, ___pass, ___last
#    ___mark0 = ___time()
#    ___mark1 = ___time()
#    ___mark2 = ___time()
#    ___entry = ___time()
    r = DEFAULT_SUCCESS
    ss = int(ss)
    center = int(center)

    if hydro<0:
        hydro = not int(_self.get_setting_boolean("auto_remove_hydrogens"))
    if (selection not in _self.get_names('all')
            if selection == 'pk1' # legacy, calling functions should pass '?pk1'
            else _self.count_atoms(selection) == 0):
        if object == "":
            object = amino_acid
        # create new object 
        if amino_acid in _self.get_names("objects"):
            raise pymol.CmdException("an object with that name already exists")
        r = _self.fragment(amino_acid,object)
        if not hydro:
            _self.remove("(hydro and %s)"%object)
        if _self.count_atoms("((%s) and name C)"%object):
            _self.edit("((%s) and name C)"%object)
        elif _self.count_atoms("((%s) and name N)"%object):
            _self.edit("((%s) and name N)"%object)
    elif _self.select(tmp_connect,"(%s) & elem N,C"%selection) != 1:
        _self.delete(tmp_wild)
        raise pymol.CmdException("invalid connection point: must be one atom, name N or C.")
    elif amino_acid in ["nhh","nme"] and _self.select(tmp_connect,"(%s) & elem C"%selection) != 1:
        _self.delete(tmp_wild)
        raise pymol.CmdException("invalid connection point: must be C for residue '%s'"%(amino_acid))
    elif amino_acid in ["ace"] and _self.select(tmp_connect,"(%s) & elem N"%selection) != 1:
        _self.delete(tmp_wild)
        raise pymol.CmdException("invalid connection point: must be N for residue '%s'"%(amino_acid))
    else:
        if ss<0:
            ss = _self.get_setting_int("secondary_structure")
        if ss:
            if ss==1: # helix
                phi=-57.0
                psi=-47.0
            elif ss==2: # antipara-beta
                phi=-139.0
                psi=135.0
            elif ss==3: # para-beta
                phi=-119.0
                psi=113.0
            else:
                phi=180.0
                psi=180.0
        _self.fragment(amino_acid,tmp_editor, origin=0)
        if _self.count_atoms("elem N",domain=tmp_connect):
            tmp = [ None ]
            _self.iterate(tmp_connect,"tmp[0]=resv", space={ 'tmp' : tmp })
            tmp[0] = str(tmp[0]-1) # counting down
            _self.alter(tmp_editor,"resi=tmp[0]",space={ 'tmp' : tmp})
            _self.set_geometry(tmp_connect, 3, 3) # make nitrogen planar
            _self.fuse("(%s and name C)"%(tmp_editor),tmp_connect,2)
            _self.select(tmp_domain, "byresi (pk1 | pk2)")

            if not hydro:
                _self.remove("(pkmol and hydro)")

            if ((_self.select(tmp1,"?pk1",domain=tmp_domain)==1) and
                (_self.select(tmp2,"?pk2",domain=tmp_domain)==1)):

                if ((_self.select(tmp3,"(name CA,CH3 & nbr. ?pk1)",domain=tmp_domain)==1) and
                    (_self.select(tmp4,"(name CA,CH3 & nbr. ?pk2)",domain=tmp_domain)==1)):
                    _self.set_dihedral(tmp4,tmp2,tmp1,tmp3,180.0) 

                if hydro:
                    _self.h_fix(tmp2) # fix hydrogen position

                if ss:
                    if amino_acid[0:3]!='pro':
                        if ((_self.select(tmp4,
                                          "(!(resn PRO) & name C  & nbr. (name CA & nbr. "+tmp2+"))",
                                          domain=tmp_domain)==1) and
                            (_self.select(tmp3,
                                          "(!(resn PRO) & name CA & nbr. "+tmp2+")",
                                          domain=tmp_domain)==1)):
                            _self.set_dihedral( # PHI
                                tmp4, # C
                                tmp3, # CA 
                                tmp2, # N
                                tmp1, # C
                                phi)

                    if ((_self.select(tmp4,"(name N & nbr. (name CA & nbr. "+tmp1+"))",
                                      domain=tmp_domain)==1) and
                        (_self.select(tmp3,"(name CA & nbr. "+tmp1+")",domain=tmp_domain)==1)):
                        _self.set_dihedral( # PSI (n-1)
                            tmp2, # N
                            tmp1, # C
                            tmp3, # CA
                            tmp4, # N
                            psi)

            sele = ("(name N & (byres nbr. %s) &! (byres %s))"% (tmp_connect,tmp_connect))
            if _self.select(tmp1,sele,domain=tmp_domain):
                _self.edit(tmp1)
                if center:
                    _self.center(tmp1,animate=animate)
        elif _self.count_atoms("elem C",domain=tmp_connect): # forward
            tmp = [ None ]
            _self.iterate(tmp_connect,"tmp[0]=resv", space={ 'tmp' : tmp })
            tmp[0] = str(tmp[0]+1) # counting up
            _self.alter(tmp_editor,"resi=tmp[0]",space={ 'tmp' : tmp})
            _self.set_geometry(tmp_editor + " & name N", 3, 3) # make nitrogen planar
            _self.fuse("(%s and name N)"%tmp_editor,tmp_connect,2)
            _self.select(tmp_domain, "byresi (pk1 | pk2)")

            if not hydro:
                _self.remove("(pkmol and hydro)") 

            if (( _self.select(tmp1,"?pk1",domain=tmp_domain)==1) and
                ( _self.select(tmp2,"?pk2",domain=tmp_domain)==1)):

#                ___mark1 = ___time()
                if ((_self.select(tmp3,"(name CA,CH3 & nbr. ?pk1)",domain=tmp_domain)==1) and
                    (_self.select(tmp4,"(name CA,CH3 & nbr. ?pk2)",domain=tmp_domain)==1)):
                    _self.set_dihedral(tmp4,tmp2,tmp1,tmp3,180.0) 
                if hydro:
                    _self.h_fix("pk1") # fix hydrogen position
                if ss:
                    if hydro and amino_acid[0:3]=='nhh': # fix amide hydrogens
                        if ((_self.select(tmp3,"(name H1 & nbr. "+tmp1+")",domain=tmp_domain)==1) and
                            (_self.select(tmp4,"(name O & nbr. "+tmp2+")",domain=tmp_domain)==1)):
                            _self.set_dihedral(
                                tmp4, # O
                                tmp2, # C
                                tmp1, # N
                                tmp3, # H1
                                180)
                    if amino_acid[0:3]!='pro':
                        if ((_self.select(tmp3,"(name CA & nbr. "+tmp1+")",domain=tmp_domain)==1) and
                            (_self.select(tmp4,"(name C & nbr. (name CA & nbr. "+tmp1+"))",domain=tmp_domain)==1)):
                            _self.set_dihedral( # PHI
                                tmp2, # C
                                tmp1, # N
                                tmp3, # CA 
                                tmp4, # C
                                phi)
                    if ((_self.select(tmp3,"(name CA & nbr. "+tmp2+")",domain=tmp_domain)==1) and
                        (_self.select(tmp4,"(name N & nbr. (name CA & nbr. "+tmp2+"))",domain=tmp_domain)==1)):
                        _self.set_dihedral( # PSI (n-1)
                            tmp4, # N
                            tmp3, # CA
                            tmp2, # C
                            tmp1, # N
                            psi)
#            ___mark2 = ___time()
            sele = ("(name C & (byres nbr. %s) & !(byres %s))"% (tmp_connect,tmp_connect))
            if _self.select(tmp1,sele,domain=tmp_domain):
                _self.edit(tmp1)
                if center:
                    _self.center(tmp1,animate=animate)
            else:
                _self.unpick()
        elif _self.count_atoms("((%s) and elem H)"%selection):
            _self.delete(tmp_wild)
            raise pymol.CmdException("please pick a nitrogen or carbonyl carbon to grow from.")
        else:
            _self.delete(tmp_wild)
            raise pymol.CmdException("unable to attach fragment.")
    _self.delete(tmp_wild)

#    ___exit = ___time()
#    ___seg1 = ___seg1 + ___mark1 - ___entry
#    ___seg2 = ___seg2 + ___mark2 - ___mark1
#    ___seg3 = ___seg3 + ___exit  - ___mark2
#    ___total = ___total + ___exit - ___entry
#    ___pass = ___pass + 1
#    print "%0.3f %0.3f %0.3f / %0.3f + %0.3f + %0.3f = %0.3f vs %0.3f"%(___seg1/___total,___seg2/___total,___seg3/___total,
#                                                          ___seg1/___pass, ___seg2/___pass, ___seg3/___pass,
#                                                          ___total/___pass, (___time()-___last) - (___exit - ___entry))
#    ___last = ___time()

    return r

_aa_codes =  {
    'A' : 'ala',
    'B' : 'ace',
    'C' : 'cys',
    'D' : 'asp',
    'E' : 'glu',
    'F' : 'phe',
    'G' : 'gly',
    'H' : 'his',
    'I' : 'ile',
    'K' : 'lys',
    'L' : 'leu',
    'M' : 'met',
    'N' : 'asn',
    'P' : 'pro',
    'Q' : 'gln',
    'R' : 'arg',
    'S' : 'ser',
    'T' : 'thr',
    'V' : 'val',
    'W' : 'trp',
    'Y' : 'tyr',
    'Z' : 'nme',
    }

_fab_codes = {
    'peptide' : _aa_codes,
    }

_pure_number = re.compile("[0-9]+")

def _fab(input,name,mode,resi,chain,segi,state,dir,hydro,ss,quiet,_self=cmd):
    r = DEFAULT_ERROR
    code = _fab_codes.get(mode,None)
    quiet = int(quiet)
    resi = int(resi)
    state = int(state)
    dir = int(dir)
    hydro = int(hydro)

    if hydro < 0:
        hydro = not _self.get_setting_boolean("auto_remove_hydrogens")
    
    seq_len = 0
    if (mode == 'peptide') and is_string(input):
        # '123/ ADC B/234/ AFCD' to [ '123/','A','D','C','B/234/','F','C','D' ]
        frags = input.split()
        input = []
        for frag in frags:
            if '/' in frag:
                input.append(frag)
            else:
                seq_len = seq_len + len(frag)
                input.extend(list(frag))
                input.append("/") # breaks chain
    if name == None:
        name = _self.get_unused_name("obj")
    elif name in _self.get_names():
        _self.delete(name)

    suspend_undo = _self.get_setting_int("suspend_undo")
    _self.push_undo("", just_coordinates=0, finish_undo=0)
    _self.set("suspend_undo", 1, updates=0)

#    if mode in [ 'smiles' ]: # small molecule (FUTURE)
#        from chempy.champ import Champ
#        ch = Champ()
#        ch.insert_pattern_string(input)
    if mode in [ 'peptide' ]:  # polymers
        if (seq_len>99) and not quiet:
            print(" Generating a %d residue peptide from sequence..."%seq_len)
        input.reverse()
        sequence = input
        if code != None:
            while len(sequence):
                while len(sequence) and '/' in sequence[-1]:
                    part = sequence.pop().split('/')
                    if len(part)>1:
                        if len(part[-2]):
                            resi = int(part[-2])
                    if len(part)>2:
                        chain = part[-3]
                    if len(part)>3:
                        segi = part[-4]
                if len(sequence) and not _self.count_atoms("?pk1"): # new polymer segment
                    tmp_obj = _self.get_unused_name()
                    first = sequence.pop()
                    _self.fragment(code[first], tmp_obj)
                    if not hydro:
                        _self.remove(tmp_obj + ' and hydro')
                    _self.alter(tmp_obj,'resi="""%s""";chain="""%s""";segi="""%s"""'%(resi,chain,segi))
                    _self.create(name,tmp_obj+" or ?"+name,1,1,zoom=0)
                    tmp_sel = _self.get_unused_name()
                    if mode == 'peptide':
                        if dir>0:
                            _self.select(tmp_sel,"name C and "+tmp_obj)
                            resi = resi + 1
                        else:
                            _self.select(tmp_sel,"name N and "+tmp_obj)
                            resi = resi - 1
                    _self.edit(name+" in "+tmp_sel) # set the editor's pk1 selection
                    _self.delete(tmp_sel+" "+tmp_obj)
                if mode == 'peptide':
                    while len(sequence):
                        if '/' in sequence[-1]:
                            _self.unpick() # break chain at this point
                            break
                        if not _self.count_atoms("?pk1"):
                            break
                        else:
                            attach_amino_acid("pk1",code[sequence.pop()],animate=0,ss=ss,hydro=hydro,_self=_self)
                            if dir>0:
                                resi = resi + 1
                            else:
                                resi = resi - 1
    if not len(sequence):
        r = DEFAULT_SUCCESS

    _self.set("suspend_undo", suspend_undo, updates=0)
    _self.push_undo("(" + str(name) + ")", just_coordinates=0, add_objects=1)
    _self.push_undo("", just_coordinates=0, finish_undo=1)

    if _self.get_setting_int('auto_zoom'):
        _self.zoom(name)

    return r

_threeNA_to_OneNA = { "atp" : "A", "ctp" : "C", "gtp" : "G", "ttp" : "T", "utp" : "U"}
_oneNA_to_threeNA = { "A" : "atp", "C" : "ctp", "G" : "gtp", "T" : "ttp", "U" : "utp"}

_base_pair = { "DNA" : {"atp" : "ttp", "ctp" : "gtp", "gtp" : "ctp", "ttp" : "atp" },
               "RNA" : {"atp" : "utp", "ctp" : "gtp", "gtp" : "ctp", "utp" : "atp" }}

def rename_three_to_one(nuc_acid, sele, nuc_type, _self=cmd):
    """
    Renames nucleobase from 3-letter to 1-letter representation

    :param nuc_acid: (str) 3-letter nucleic acid representation
    :param sele: (str) selection of nucleic acid to rename
    :param nuc_type: (str) "DNA" or "RNA"
    """
    new_name = _threeNA_to_OneNA[nuc_acid]
    if nuc_type == "DNA":
        new_name = "D" + new_name
    _self.alter(sele, "resn='%s'" % new_name)

def fit_sugars(mobile, target, _self=cmd):
    """
    Fits appending base pairs to form appropriate hydrogen bond

    :param mobile: (str) selection for the sense (main) strand
    :param target: (str) selection for the antisense (opposing) strand
    """
    _self.pair_fit("%s & name C1'" % mobile,
                   "%s & name C1'" % target,
                   "%s & name C2'" % mobile,
                   "%s & name C2'" % target,
                   "%s & name C3'" % mobile,
                   "%s & name C3'" % target,
                   "%s & name C4'" % mobile,
                   "%s & name C4'" % target,
                   "%s & name O4'" % mobile,
                   "%s & name O4'" % target, quiet=1)

def add2pO(domain, nuc_acid, resv, _self=cmd):
    if nuc_acid == "utp": #utp comes with O2'
        return
    c_2p = _prefix + "_c2p"
    _self.select(c_2p, "%s & resi \\%i & name %s" % (domain, resv, "C2'"))
    _self.unpick()
    _self.edit(c_2p)
    _self.attach("O", 4, 4)
    _self.unpick()
    _self.alter("(byres %s) & resi \\%i & name O01" % (domain, resv), "name=\"O2'\"")

def move_new_res(nuc_acid, new, old, form, antisense=False, _self=cmd):
    """
    Attaches new residue onto current nucleotide chain

    :param nuc_acid: (str) Appending nucleic acid name
    :param new: (str) Selection of new unpositioned residue
    :param old: (str) Selection of previous residue
    :param antisense (bool) Flag for antisense
    :param form: (str) DNA form ('A'/'B')
    """
    if form == 'B':
        twist = -36.0
        rise = -3.375
    elif form == 'A':
        twist = -32.7
        rise = -2.548
    else:
        raise ValueError("Form not recognized")

    rise = rise if antisense else -rise
    twist = twist if antisense else -twist

    dummy_fragment = "dummyfrag"
    _self.fragment(nuc_acid + form, dummy_fragment, origin=0)
    atoms = []
    _self.iterate(dummy_fragment, "atoms.append(name)", space={'atoms': atoms})

    #A new base is created by copying the coordinates of the previous
    #base and doing a cylindrical rotation (phi degrees) and a translation
    #down the z-axis by the rise amount
    for atom in atoms:
        prev_coords = _self.get_coords("%s & name %s" % (dummy_fragment, atom), state=1)
        curr_coords = _self.get_coords("%s & name %s" % (new, atom), state=1)

        if curr_coords is None or prev_coords is None:
            continue
        curr_coord = curr_coords[0]
        prev_coord = prev_coords[0]

        r = math.sqrt(prev_coord[0] ** 2 +
                      prev_coord[1] ** 2)
        old_phi = math.degrees(math.atan2(prev_coord[1],prev_coord[0]))
        phi = old_phi - twist
        phi = math.radians(phi)
        new_pos = [r * math.cos(phi),
                   r * math.sin(phi),
                   prev_coord[2] - rise]

        trans = list(new_pos - curr_coord)
        _self.translate(trans, "%s & name %s" % (new, atom), camera=0)

    fit_sugars(dummy_fragment, old)
    dummy_fragment_transform = _self.get_object_matrix(dummy_fragment)
    _self.transform_object(new, dummy_fragment_transform)
    _self.delete(dummy_fragment)

def start_antisense(sense_sele, nuc_acid_partner, nuc_type, form, sense_resv, _self=cmd):
    """
    Begin creation of double strand. Will eventually be suitable for both
    new chain creation and starting a double strand from existing single
    strand.

    :param sense_sele: (str) Selection for sense strand (single residue)
    :param nuc_acid_partner: (str) Base type for new residue on antisense strand
    :param nuc_type: (str) DNA/RNA
    :param form: (str) A/B
    :param sense_resv: Current resv on the sense strand
    """
    partner_fragment_name = nuc_acid_partner + form
    object_oppo = sense_sele + "_oppo"
    _self.fragment(partner_fragment_name, object_oppo)
    _self.alter(object_oppo, "segi='B';chain='B';resv=%i;p.dna_form='%s'" % (-sense_resv, form))
    rename_three_to_one(nuc_acid_partner, object_oppo, nuc_type)

    dummy_fragment = "dummy_fragment"
    _self.fragment("atp" + form, dummy_fragment)

    # other strand has inverted y and z
    atoms = []
    _self.iterate(sense_sele, "atoms.append(name)", space={'atoms': atoms})

    for atom in atoms:
        object_coords = _self.get_coords("%s & name %s" % (sense_sele, atom), state=1)
        dummy_coords = _self.get_coords("%s & name %s" % (dummy_fragment, atom), state=1)

        if object_coords is None or dummy_coords is None:
            continue

        object_coord = object_coords[0]
        dummy_coord = dummy_coords[0]
        new_pos = [object_coord[0], -object_coord[1], -object_coord[2]]
        trans = list(new_pos - dummy_coord)
        _self.translate(trans, "%s & name %s" % (dummy_fragment, atom), camera=0)

    fit_sugars(object_oppo, dummy_fragment)
    _self.delete(dummy_fragment)
    _self.fuse(object_oppo, sense_sele, mode=3)
    _self.delete(object_oppo)

class NascentNucAcidInfo:
    def __init__(self, fragment_name, nuc_acid, nuc_type, form, dbl_helix):
        self.fragment_name = fragment_name
        self.nuc_acid = nuc_acid
        self.nuc_type = nuc_type
        self.form = form
        self.dbl_helix = dbl_helix

def check_valid_attachment(nascent, prev_form, atom_selection_name, selection, resv, _self=cmd):
    if prev_form is None:
        _self.delete(tmp_wild)
        raise pymol.CmdException("%s extension only available on molecules generated by nucleic acid builder."
                                 % nascent.nuc_type)

    if prev_form != nascent.form:
        _self.delete(tmp_wild)
        raise pymol.CmdException("Switching forms within chain not currently supported.")

    atom_selection_name_partner = "O3'" if atom_selection_name == "P" else "P"
    atom_sele = _prefix + "atom_sele"
    _self.select(atom_sele, "%s" % (selection))
    bound = _prefix + "atom_sele_bound"
    if _self.count_atoms("(bound_to %s) & name %s" %
                           (atom_sele, atom_selection_name_partner)) != 0:
        _self.delete(tmp_wild)
        raise pymol.CmdException("%s already bonded!" % atom_selection_name)

def extend_nuc_acid(nascent, nascent_partner, selection,
              object, atom_selection_name, chain = 'A', _self=cmd):
    """
    Creates new nuc acid (or pair) or attaches to nascent chain
    :param nascent: (NascentNucAcidInfo) appending nucleic acid
    :param nascent_partner: (NascentNucAcidInfo) partner of appending nucleic acid
    :param selection: (str) selection string of selected residue
    :param object: (str) object of selected residue
    :param atom_selection_name: (str) O3' or P
    :param chain: (str) chain ID (A or B)
    """

    _self.fragment(nascent.fragment_name, tmp_editor, origin=0)
    rename_three_to_one(nascent.nuc_acid, tmp_editor, nascent.nuc_type)

    if atom_selection_name != "O3'" and atom_selection_name != "P":
        raise ValueError("Unacceptable atom name %s" % atom_selection_name)
    if chain != 'A' and chain != 'B':
        raise ValueError("Unacceptable chain name %s" % chain)

    chain_oppo = 'B' if chain == 'A' else 'A'
    atom_name_oppo = "O3'" if atom_selection_name == "P" else "P"

    if _self.count_atoms("name %s" % atom_selection_name, domain=tmp_connect):

        tmp_prop = [None, None]
        _self.iterate(tmp_connect, "tmp_prop[0]=resv;tmp_prop[1]=p.dna_form",
                      space={'tmp_prop': tmp_prop})

        if chain == 'A' and atom_selection_name == "O3'":
            tmp_prop[0] = str(tmp_prop[0] + 1)
        elif chain == 'B' and atom_selection_name == "O3'":
            tmp_prop[0] = str(0)
        elif chain == 'A' and atom_selection_name == "P":
            tmp_prop[0] = str(0)
        else: #chain == 'B' and atom_selection_name == "P":
            tmp_prop[0] = str(tmp_prop[0] - 1)

        prev_form = tmp_prop[1]

        resi = tmp_prop[0]
        resv = int(resi)

        check_valid_attachment(nascent, prev_form, atom_selection_name, selection, resv)

        _self.alter(tmp_editor, "chain='%s';segi='%s';resi=tmp_prop[0];p.dna_form='%s'" % (chain, chain, nascent.form),
                    space={'tmp_prop': tmp_prop})
        last_resi_sele = _prefix + "_last_resi"

        if chain == 'A' and atom_selection_name == "O3'":
            last_resv = resv - 1
        elif chain == 'B' and atom_selection_name == "O3'":
            last_resv = -1
        elif chain == 'A' and atom_selection_name == "P":
            last_resv = 1
        else: # chain == 'B' and atom_selection_name == "P":
            last_resv = resv + 1

        _self.select(last_resi_sele, "(byobject %s) & segi %s & resi \\%i" % (selection, chain, last_resv))

        reverse = False if atom_selection_name == "O3'" else True

        move_new_res(nascent.nuc_acid, tmp_editor, last_resi_sele, nascent.form, antisense=reverse)

        _self.fuse("%s & name P" % tmp_editor, tmp_connect, mode=3)

        _self.select(tmp_domain, "byresi (pk1 | pk2)")


        if chain == 'A' and atom_selection_name == "O3'":
            _self.bond("%s & resi \\%i & name O3'" % (tmp_domain, resv - 1),
                       "%s & resi \\%i & name P" % (tmp_domain, resv))
        elif chain == 'B' and atom_selection_name == "O3'":
            resv = resv -1
            chainSele =  "_chainSele"
            _self.select(chainSele, "(byobject %s) & segi %s" % (selection, chain))
            _self.alter(chainSele, "resi=str(int(resi) - 1)")
            _self.bond("%s & resi \\%i & name O3'" % (tmp_domain, -2),
                       "%s & resi \\%i & name P" % (tmp_domain, -1))
        elif chain == 'A' and atom_selection_name == "P":
            resv = resv + 1
            chainSele = "_chainSele"
            _self.select(chainSele, "(byobject %s) & segi %s" % (selection, chain))
            _self.alter(chainSele, "resi=str(int(resi) + 1)")
            _self.bond("%s & resi \\%i & name O3'" % (tmp_domain, 1),
                       "%s & resi \\%i & name P" % (tmp_domain, 2))
        else: # chain == 'B' and atom_selection_name == "P":
            _self.bond("%s & resi \\%i & name O3'" % (tmp_domain, resv),
                       "%s & resi \\%i & name P" % (tmp_domain, resv + 1))

        if nascent.dbl_helix:
            prev_oppo_res = _prefix + "_B_prev"

            if chain == 'A' and atom_selection_name == "O3'":
                pres_resv_j = -resv + 1
            elif chain == 'B' and atom_selection_name == "O3'":
                pres_resv_j = -resv
            elif chain == 'A' and atom_selection_name == "P":
                pres_resv_j = -resv
            else: # chain == 'B' and atom_selection_name == "P":
                pres_resv_j = -resv -1

            if (_self.select(prev_oppo_res, "(byobject %s) & segi %s & resi \\%i"
                                            % (selection, chain_oppo, pres_resv_j)) == 0):
                # TODO: Implement in-chain addition of double stranded DNA
                print("Adding double strand from single strand not currently supported.")
            else:
                object_oppo = object + "_oppo"
                _self.fragment(nascent_partner.fragment_name, object_oppo)
                _self.alter(object_oppo, "chain='%s';segi='%s';resv=%i;p.dna_form='%s'" %
                            (chain_oppo, chain_oppo, -resv, nascent_partner.form))
                rename_three_to_one(nascent_partner.nuc_acid, object_oppo, nascent_partner.nuc_type)

                object_oppo_connect_P = _prefix + "_oppo_%s_conP" % chain_oppo
                _self.select(object_oppo_connect_P, "%s & name %s" % (prev_oppo_res, atom_name_oppo))

                reverse = True if atom_selection_name == "O3'" else False
                if chain == "B" and atom_selection_name == "O3'":
                    chainSele = "_chainSele"
                    _self.select(chainSele, "(byobject %s) & segi %s" % (selection, 'A'))
                    _self.alter(chainSele, "resi=str(int(resi) + 1)")
                elif chain == "A" and atom_selection_name == "P":
                    chainSele = "_chainSele"
                    _self.select(chainSele, "(byobject %s) & segi %s" % (selection, 'B'))
                    _self.alter(chainSele, "resi=str(int(resi) - 1)")

                move_new_res(nascent_partner.nuc_acid, object_oppo,
                             prev_oppo_res, nascent_partner.form, antisense=reverse)

                _self.fuse("%s & name %s" % (object_oppo, atom_selection_name), object_oppo_connect_P, mode=3)

                object_oppo_connect_O3p = _prefix + "_oppo_%s_conO" % chain_oppo

                _self.select(object_oppo_connect_O3p, "(byobject %s) & segi %s & resi \\%i & name %s" %
                             (selection, chain_oppo, -resv, atom_selection_name))

                _self.bond(object_oppo_connect_O3p, object_oppo_connect_P)
                _self.delete(object_oppo)

        new_term = _prefix + "_tmp1"
        _self.select(new_term, "%s & resi \\%i & name %s" % (tmp_domain, resv, atom_selection_name))
        if nascent.nuc_type == "RNA":
            add2pO(tmp_domain, nascent.nuc_acid, resv)

        _self.edit(new_term)

def attach_nuc_acid(selection, nuc_acid, nuc_type, object="", form='B',
                    dbl_helix=True, _self=cmd):
    """
    Creates new nuc acid (or pair) or attaches to nascent chain

    :param selection: (str) selection of picked nascent chain (or nothing)
    :param nuc_acid: (str) appending nucleic acid
    :param nuc_type: (str) sugar type of nucleic acid
    :param object: (str) name of appending nucleobase
    :param form: (str) DNA structure form: A, B, or Z
    :param dbl_helix: (bool) flag for double-strandedness
    """
    if nuc_type == "RNA" and form != 'A':
        form = 'A'
        dbl_helix = False

    nascent = NascentNucAcidInfo(nuc_acid + form, nuc_acid, nuc_type, form, dbl_helix)
    nuc_acid_partner_temp = _base_pair[nuc_type][nuc_acid].lower()
    nascent_partner = NascentNucAcidInfo(nuc_acid_partner_temp + form, nuc_acid_partner_temp,
                                         nuc_type, form, dbl_helix)
    if _self.cmd.count_atoms(selection) == 0:
        if object == "":
            object = amino_acid

        _self.fragment(nascent.fragment_name, object, origin=0)
        _self.alter(object, "segi='A';chain='A';resv=1;p.dna_form='%s'" % nascent.form)
        rename_three_to_one(nascent.nuc_acid, object, nascent.nuc_type)

        if dbl_helix:
            start_antisense(object, nascent_partner.nuc_acid, nascent_partner.nuc_type,
                            nascent_partner.form, sense_resv=1)
            _self.translate(_self.get_position(), object, camera=0)

        if nascent.nuc_type == "RNA":
            add2pO(object, nascent.nuc_acid, 1)

        if _self.count_atoms("%s & segi A & name P" % object):
            _self.edit("%s & segi A & name P" % object)
        elif _self.count_atoms("%s & segi A & name O3'" % object):
            _self.edit("%s & segi A & name O3'" % object)
        _self.edit("%s & segi A & name O3'" % object)
    elif _self.select(tmp_connect, "(%s) & segi A & name O3'" % selection) == 1:
        extend_nuc_acid(nascent, nascent_partner, selection, object, "O3'", 'A', _self)
    elif _self.select(tmp_connect, "(%s) & segi A & name P" % selection) == 1:
        extend_nuc_acid(nascent, nascent_partner, selection, object, "P", 'A', _self)
    elif _self.select(tmp_connect, "(%s) & segi B & name O3'" % selection) == 1:
        extend_nuc_acid(nascent, nascent_partner, selection, object, "O3'", 'B', _self)
    elif _self.select(tmp_connect, "(%s) & segi B & name P" % selection) == 1:
        extend_nuc_acid(nascent, nascent_partner, selection, object, "P", 'B', _self)
    else:
        _self.delete(tmp_wild)
        raise pymol.CmdException("invalid connection point: must be one atom, name O3' or P")

    _self.show("cartoon", "byobject %s" % selection)
    _self.delete(tmp_wild)

def fab(input,name=None,mode='peptide',resi=1,chain='',segi='',state=-1,
        dir=1,hydro=-1,ss=0,async_=0,quiet=1,_self=cmd, **kwargs):
    '''
DESCRIPTION

    Build a peptide

ARGUMENTS

    input = str: sequence in one-letter code

    name = str: name of object to create {default: }

    ss = int: Secondary structure 1=alpha helix, 2=antiparallel beta, 3=parallel beta, 4=flat

EXAMPLE

    fab ACDEFGH
    fab ACDEFGH, helix, ss=1
    '''
    async_ = int(kwargs.pop('async', async_))

    if kwargs:
        raise pymol.CmdException('unknown argument: ' + ', '.join(kwargs))

    if async_ < 1:
        r = _fab(input,name,mode,resi,chain,segi,
                 state,dir,hydro,ss,quiet,_self)
    else:
        fab_thread = threading.Thread(target=_fab, args=(input,name,mode,
                                                         resi,chain,
                                                         segi,state,dir,
                                                         hydro,ss,quiet,_self))
        fab_thread.setDaemon(1)
        fab_thread.start()
        r = DEFAULT_SUCCESS
    return r

def fnab(input, name=None, mode="DNA", form="B", dbl_helix=1, _self=cmd):
    """
DESCRIPTION

    Builds a nucleotide acid from sequence

USAGE

    fnab input [, name [, type [, form [, dbl_helix ]]]]

ARGUMENTS

    input = str: Sequence as an array of one letter codes

    name = str: Name of the object to create {default: obj}

    mode = str: "DNA" or "RNA"

    form = str: "A" or "B"

    dbl_helix = bool (0/1): flag for using double helix in DNA

EXAMPLE

    fnab ATGCGATAC
    fnab ATGCGATAC, name=myDNA, mode=DNA, form=B, dbl_helix=1
    fnab AAUUUUCCG, mode=RNA
    """
    _self.unpick()

    if name is None:
        name = _self.get_unused_name(prefix="obj")
    elif name in _self.get_names('all'):
        name = _self.get_unused_name(prefix=name)

    dbl_helix = int(dbl_helix) > 0

    mode = mode.upper()
    if mode not in ('DNA', 'RNA'):
        raise pymol.CmdException("\"mode\" must be \"DNA\" or \"RNA\" only.")

    #first pass for error checking
    for oneNA in input:
        oneNA = oneNA.upper()
        threeNA = _oneNA_to_threeNA.get(oneNA)
        if threeNA is None:
            raise pymol.CmdException("\"%s\" not of %s type..." % (oneNA, mode))

        if threeNA not in _base_pair[mode]:
            raise pymol.CmdException("\"%s\" not of %s type..." % (oneNA, mode))

    for oneNA in input:
        oneNA = oneNA.upper()
        threeNA = _oneNA_to_threeNA[oneNA]
        attach_nuc_acid(selection="?pk1", nuc_acid=threeNA, nuc_type=mode,
                        object=name, form=form, dbl_helix=dbl_helix)
    _self.unpick()
    return DEFAULT_SUCCESS

def build_peptide(sequence,_self=cmd): # legacy
    for aa in sequence:
        attach_amino_acid("pk1",_aa_codes[aa])
        
